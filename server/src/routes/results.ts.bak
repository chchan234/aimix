/**
 * Results API Routes
 * Endpoints for managing user service results
 */

import express from 'express';
import { db } from '../db/index.js';
import { serviceResults, services } from '../db/schema.js';
import { authenticateToken } from '../middleware/auth.js';
import { eq, and, desc } from 'drizzle-orm';

const router = express.Router();

/**
 * GET /api/results/:id (PUBLIC)
 * Get a specific result by ID - publicly accessible for sharing
 */
router.get('/:id', async (req, res) => {
  try {
    const resultId = req.params.id;

    const result = await db
      .select({
        id: serviceResults.id,
        serviceId: serviceResults.serviceId,
        resultData: serviceResults.resultData,
        createdAt: serviceResults.createdAt,
        serviceType: services.serviceType,
      })
      .from(serviceResults)
      .innerJoin(services, eq(serviceResults.serviceId, services.id))
      .where(eq(serviceResults.id, resultId))
      .limit(1);

    if (result.length === 0) {
      return res.status(404).json({
        error: 'Result not found',
      });
    }

    res.json(result[0]);
  } catch (error) {
    console.error('Error fetching result:', error);
    res.status(500).json({
      error: 'Failed to fetch result',
    });
  }
});

// Apply authentication to remaining routes
router.use(authenticateToken);

/**
 * POST /api/results
 * Save a new result for the authenticated user
 */
router.post('/', async (req, res) => {
  try {
    const userId = req.user!.userId;
    const { serviceType, inputData, resultData, aiModel, tokensUsed, processingTime } = req.body;

    if (!serviceType || !resultData) {
      return res.status(400).json({
        error: 'serviceType and resultData are required',
      });
    }

    // Create service record first
    const [service] = await db
      .insert(services)
      .values({
        userId,
        serviceType,
        inputData: inputData || {},
        status: 'completed',
        creditCost: 0,
        processingTime: processingTime || 0,
        completedAt: new Date(),
      })
      .returning();

    // Set expiry date to 12 months from now
    const expiresAt = new Date();
    expiresAt.setMonth(expiresAt.getMonth() + 12);

    // Create result record linked to service
    const [newResult] = await db
      .insert(serviceResults)
      .values({
        serviceId: service.id,
        resultData,
        aiModel,
        tokensUsed: tokensUsed || 0,
      })
      .returning();

    res.json({
      success: true,
      result: newResult,
      message: 'Result saved successfully',
    });
  } catch (error) {
    console.error('Error saving result:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to save result',
    });
  }
});

/**
 * GET /api/results
 * Get all results for the authenticated user
 */
router.get('/', async (req, res) => {
  try {
    const userId = req.user!.userId;
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 20;
    const serviceType = req.query.serviceType as string;
    const offset = (page - 1) * limit;

    // Always join with services table to filter by userId
    let query = db
      .select({
        id: serviceResults.id,
        serviceId: serviceResults.serviceId,
        resultData: serviceResults.resultData,
        aiModel: serviceResults.aiModel,
        tokensUsed: serviceResults.tokensUsed,
        createdAt: serviceResults.createdAt,
        serviceType: services.serviceType,
      })
      .from(serviceResults)
      .innerJoin(services, eq(serviceResults.serviceId, services.id))
      .where(eq(services.userId, userId))
      .orderBy(desc(serviceResults.createdAt))
      .limit(limit)
      .offset(offset);

    // Filter by service type if provided
    if (serviceType) {
      query = db
        .select({
          id: serviceResults.id,
          serviceId: serviceResults.serviceId,
          resultData: serviceResults.resultData,
          aiModel: serviceResults.aiModel,
          tokensUsed: serviceResults.tokensUsed,
          createdAt: serviceResults.createdAt,
          serviceType: services.serviceType,
        })
        .from(serviceResults)
        .innerJoin(services, eq(serviceResults.serviceId, services.id))
        .where(
          and(
            eq(services.userId, userId),
            eq(services.serviceType, serviceType)
          )
        )
        .orderBy(desc(serviceResults.createdAt))
        .limit(limit)
        .offset(offset);
    }

    const results = await query;

    res.json({
      success: true,
      results,
      pagination: {
        page,
        limit,
        hasMore: results.length === limit,
      },
    });
  } catch (error) {
    console.error('Error fetching results:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to fetch results',
    });
  }
});

/**
 * GET /api/results/:id
 * Get a specific result by ID
 */
router.get('/:id', async (req, res) => {
  try {
    const userId = req.user!.userId;
    const resultId = req.params.id;

    const result = await db
      .select({
        id: serviceResults.id,
        serviceId: serviceResults.serviceId,
        resultData: serviceResults.resultData,
        aiModel: serviceResults.aiModel,
        tokensUsed: serviceResults.tokensUsed,
        createdAt: serviceResults.createdAt,
        serviceType: services.serviceType,
      })
      .from(serviceResults)
      .innerJoin(services, eq(serviceResults.serviceId, services.id))
      .where(
        and(
          eq(serviceResults.id, resultId),
          eq(services.userId, userId)
        )
      )
      .limit(1);

    if (result.length === 0) {
      return res.status(404).json({
        error: 'Result not found',
      });
    }

    res.json({
      success: true,
      result: result[0],
    });
  } catch (error) {
    console.error('Error fetching result:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to fetch result',
    });
  }
});

/**
 * DELETE /api/results/:id
 * Delete a specific result
 */
router.delete('/:id', async (req, res) => {
  try {
    const userId = req.user!.userId;
    const resultId = req.params.id;

    // First verify the result belongs to the user
    const result = await db
      .select({ id: serviceResults.id })
      .from(serviceResults)
      .innerJoin(services, eq(serviceResults.serviceId, services.id))
      .where(
        and(
          eq(serviceResults.id, resultId),
          eq(services.userId, userId)
        )
      )
      .limit(1);

    if (result.length === 0) {
      return res.status(404).json({
        error: 'Result not found',
      });
    }

    // Delete the result
    await db
      .delete(serviceResults)
      .where(eq(serviceResults.id, resultId));

    res.json({
      success: true,
      message: 'Result deleted successfully',
    });
  } catch (error) {
    console.error('Error deleting result:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Failed to delete result',
    });
  }
});

export default router;
